//! VNC server implementation for managing client connections and framebuffer distribution.
//!
//! This module provides the main VNC server functionality, including:
//! - TCP listener for incoming client connections
//! - Client session management
//! - Event routing between clients and the application layer
//! - VNC repeater support for reverse connections
//!
//! # Architecture
//!
//! The server uses an event-driven architecture where:
//! - Each client runs in its own asynchronous task
//! - Client events (keyboard, mouse, clipboard) are forwarded to the application via channels
//! - The framebuffer automatically notifies all clients of screen changes
//! - Server events (connect/disconnect) are emitted for the application to handle

use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::{mpsc, RwLock};
use log::{info, error};

use crate::vnc::framebuffer::{Framebuffer, DirtyRegionReceiver};
use crate::vnc::client::{VncClient, ClientEvent};
use crate::vnc::repeater;

/// Global atomic counter for assigning unique client IDs.
///
/// This counter is incremented for each new client connection to ensure
/// each client has a unique identifier throughout the server's lifetime.
static NEXT_CLIENT_ID: AtomicU64 = AtomicU64::new(1);

/// Represents a VNC server instance.
///
/// This struct manages the VNC framebuffer, connected clients, and handles server-wide events.
pub struct VncServer {
    /// The VNC framebuffer, representing the remote desktop screen.
    framebuffer: Framebuffer,
    /// The name of the desktop, displayed to connected clients.
    desktop_name: String,
    /// Optional password for client authentication.
    password: Option<String>,
    /// A list of currently connected VNC clients, protected by a `RwLock` for concurrent access.
    clients: Arc<RwLock<Vec<Arc<RwLock<VncClient>>>>>,
    /// Sender for server-wide events, used to notify external components of VNC server activity.
    event_tx: mpsc::UnboundedSender<ServerEvent>,
}

/// Enum representing various events that can occur within the VNC server.
pub enum ServerEvent {
    /// A new client has connected to the VNC server.
    ///
    /// * `client_id` - The unique identifier for the newly connected client.
    ClientConnected { client_id: usize },
    /// A client has disconnected from the VNC server.
    ///
    /// * `client_id` - The unique identifier for the disconnected client.
    ClientDisconnected { client_id: usize },
    /// A key press or release event was received from a client.
    ///
    /// * `client_id` - The unique identifier of the client that sent the event.
    /// * `down` - A boolean indicating if the key was pressed (`true`) or released (`false`).
    /// * `key` - The VNC keysym value of the key.
    KeyPress { client_id: usize, down: bool, key: u32 },
    /// A pointer (mouse) movement or button event was received from a client.
    ///
    /// * `client_id` - The unique identifier of the client that sent the event.
    /// * `x` - The X coordinate of the pointer.
    /// * `y` - The Y coordinate of the pointer.
    /// * `button_mask` - A bitmask indicating the state of mouse buttons.
    PointerMove { client_id: usize, x: u16, y: u16, button_mask: u8 },
    /// Cut text (clipboard) data was received from a client.
    ///
    /// * `client_id` - The unique identifier of the client that sent the event.
    /// * `text` - The cut text string.
    CutText { client_id: usize, text: String },
}

impl VncServer {
    /// Creates a new `VncServer` instance.
    ///
    /// This function initializes the framebuffer, sets up desktop name and password, and prepares
    /// channels for server events.
    ///
    /// # Arguments
    ///
    /// * `width` - The width of the VNC framebuffer.
    /// * `height` - The height of the VNC framebuffer.
    /// * `desktop_name` - The name of the desktop to be advertised to clients.
    /// * `password` - An optional password for client authentication.
    ///
    /// # Returns
    ///
    /// A tuple containing:
    /// * The `VncServer` instance itself.
    /// * An `mpsc::UnboundedReceiver<ServerEvent>` to receive events generated by the server.
    pub fn new(
        width: u16,
        height: u16,
        desktop_name: String,
        password: Option<String>,
    ) -> (Self, mpsc::UnboundedReceiver<ServerEvent>) {
        let (event_tx, event_rx) = mpsc::unbounded_channel();

        let server = Self {
            framebuffer: Framebuffer::new(width, height),
            desktop_name,
            password,
            clients: Arc::new(RwLock::new(Vec::new())),
            event_tx,
        };

        (server, event_rx)
    }

    /// Starts the VNC server, listening for incoming client connections on the specified port.
    ///
    /// This function enters an infinite loop, accepting new TCP connections and spawning
    /// a new asynchronous task to handle each client.
    ///
    /// # Arguments
    ///
    /// * `port` - The TCP port on which the server will listen for connections.
    ///
    /// # Returns
    ///
    /// `Ok(())` if the server starts successfully and listens indefinitely.
    /// Returns `Err(std::io::Error)` if there is an issue binding to the port or accepting connections.
    pub async fn listen(&self, port: u16) -> Result<(), std::io::Error> {
        let listener = TcpListener::bind(format!("0.0.0.0:{}", port)).await?;
        info!("VNC Server listening on port {}", port);

        loop {
            match listener.accept().await {
                Ok((stream, addr)) => {
                    info!("New VNC client connection from: {}", addr);

                    // Safely increment client ID counter and check for overflow
                    let client_id_raw = NEXT_CLIENT_ID.fetch_add(1, Ordering::SeqCst);
                    if client_id_raw == 0 || client_id_raw >= u64::MAX - 1000 {
                        error!("Client ID counter overflow, rejecting connection from {}", addr);
                        continue;
                    }
                    let client_id = client_id_raw as usize;

                    let framebuffer = self.framebuffer.clone();
                    let desktop_name = self.desktop_name.clone();
                    let password = self.password.clone();
                    let clients = self.clients.clone();
                    let server_event_tx = self.event_tx.clone();

                    tokio::spawn(async move {
                        if let Err(e) = Self::handle_client(
                            stream,
                            client_id,
                            framebuffer,
                            desktop_name,
                            password,
                            clients,
                            server_event_tx,
                        )
                        .await
                        {
                            error!("Client {} error: {}", client_id, e);
                        }
                    });
                }
                Err(e) => {
                    error!("Error accepting connection: {}", e);
                }
            }
        }
    }

    async fn handle_client(
        stream: TcpStream,
        client_id: usize,
        framebuffer: Framebuffer,
        desktop_name: String,
        password: Option<String>,
        clients: Arc<RwLock<Vec<Arc<RwLock<VncClient>>>>>,
        server_event_tx: mpsc::UnboundedSender<ServerEvent>,
    ) -> Result<(), std::io::Error> {
        let (client_event_tx, mut client_event_rx) = mpsc::unbounded_channel();

        let client = VncClient::new(
            stream,
            framebuffer.clone(),
            desktop_name,
            password,
            client_event_tx,
        )
        .await?;

        let client_arc = Arc::new(RwLock::new(client));

        // Register client to receive dirty region notifications (libvncserver style)
        let regions_arc = client_arc.read().await.get_receiver_handle();
        let receiver = DirtyRegionReceiver::new(Arc::downgrade(&regions_arc));
        framebuffer.register_receiver(receiver).await;

        clients.write().await.push(client_arc.clone());

        let _ = server_event_tx.send(ServerEvent::ClientConnected { client_id });

        // Spawn task to handle client messages
        // Note: The message handler holds a write lock for its duration, which means
        // operations like send_cut_text() will wait for the lock. This is acceptable
        // since clipboard operations are infrequent and the async lock prevents deadlocks.
        let client_arc_clone = client_arc.clone();
        tokio::spawn(async move {
            let result = {
                let mut client = client_arc_clone.write().await;
                client.handle_messages().await
            };
            if let Err(e) = result {
                error!("Client {} message handling error: {}", client_id, e);
            }
        });

        // Handle client events
        while let Some(event) = client_event_rx.recv().await {
            match event {
                ClientEvent::KeyPress { down, key } => {
                    let _ = server_event_tx.send(ServerEvent::KeyPress {
                        client_id,
                        down,
                        key,
                    });
                }
                ClientEvent::PointerMove { x, y, button_mask } => {
                    let _ = server_event_tx.send(ServerEvent::PointerMove {
                        client_id,
                        x,
                        y,
                        button_mask,
                    });
                }
                ClientEvent::CutText { text } => {
                    let _ = server_event_tx.send(ServerEvent::CutText { client_id, text });
                }
                ClientEvent::Disconnected => {
                    break;
                }
            }
        }

        // Remove client from list
        let mut clients_guard = clients.write().await;
        clients_guard.retain(|c| !Arc::ptr_eq(c, &client_arc));

        let _ = server_event_tx.send(ServerEvent::ClientDisconnected { client_id });

        info!("Client {} disconnected", client_id);
        Ok(())
    }

    /// Returns a reference to the server's `Framebuffer`.
    ///
    /// This allows external components to inspect or modify the framebuffer content.
    ///
    /// # Returns
    ///
    /// A reference to the `Framebuffer` instance.
    pub fn framebuffer(&self) -> &Framebuffer {
        &self.framebuffer
    }

    /// Returns a mutable reference to the server's `Framebuffer`.
    ///
    /// This allows external components to modify the framebuffer, including resizing.
    ///
    /// # Returns
    ///
    /// A mutable reference to the `Framebuffer` instance.
    pub fn framebuffer_mut(&mut self) -> &mut Framebuffer {
        &mut self.framebuffer
    }

    /// Sends the provided cut text (clipboard) to all currently connected VNC clients.
    ///
    /// # Arguments
    ///
    /// * `text` - The string content to be sent as cut text.
    ///
    /// # Returns
    ///
    /// `Ok(())` if the text is successfully queued for sending to all clients.
    /// Returns `Err(std::io::Error)` if an error occurs during the sending process to any client.
    pub async fn send_cut_text_to_all(&self, text: String) -> Result<(), std::io::Error> {
        // Clone the client list before iterating to avoid holding read lock
        // This prevents deadlock with client message handlers
        let clients_snapshot = {
            let clients = self.clients.read().await;
            clients.clone()
        };

        for client in clients_snapshot.iter() {
            let mut client_guard = client.write().await;
            let _ = client_guard.send_cut_text(text.clone()).await;
        }
        Ok(())
    }

    /// Establishes a direct reverse VNC connection to a client viewer.
    ///
    /// This method initiates an outbound TCP connection to a VNC viewer listening
    /// for reverse connections. Unlike `connect_repeater`, this is a direct connection
    /// without the repeater protocol overhead.
    ///
    /// # Arguments
    ///
    /// * `host` - The hostname or IP address of the VNC viewer.
    /// * `port` - The port on which the VNC viewer is listening.
    ///
    /// # Returns
    ///
    /// `Ok(client_id)` if the reverse connection is successfully established.
    /// Returns `Err(std::io::Error)` if the connection fails or a client ID overflow occurs.
    pub async fn connect_reverse(
        &self,
        host: String,
        port: u16,
    ) -> Result<usize, std::io::Error> {
        // Safely increment client ID counter and check for overflow
        let client_id_raw = NEXT_CLIENT_ID.fetch_add(1, Ordering::SeqCst);
        if client_id_raw == 0 || client_id_raw >= u64::MAX - 1000 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Client ID counter overflow"
            ));
        }
        let client_id = client_id_raw as usize;

        info!("Initiating reverse VNC connection to {}:{}", host, port);

        let framebuffer = self.framebuffer.clone();
        let desktop_name = self.desktop_name.clone();
        let password = self.password.clone();
        let clients = self.clients.clone();
        let server_event_tx = self.event_tx.clone();

        // Use oneshot channel to wait for connection result before returning
        let (result_tx, result_rx) = tokio::sync::oneshot::channel();

        tokio::spawn(async move {
            let (client_event_tx, mut client_event_rx) = mpsc::unbounded_channel();

            // Establish direct TCP connection to the viewer
            let connection_result = TcpStream::connect(format!("{}:{}", host, port)).await;

            match connection_result {
                Ok(stream) => {
                    info!("TCP connection established to {}:{}", host, port);

                    // Create VNC client for this reverse connection
                    let client_result = VncClient::new(
                        stream,
                        framebuffer.clone(),
                        desktop_name,
                        password,
                        client_event_tx,
                    )
                    .await;

                    // Send connection result back to caller
                    let _ = result_tx.send(client_result.as_ref().map(|_| ()).map_err(|e| {
                        std::io::Error::new(e.kind(), e.to_string())
                    }));

                    match client_result {
                        Ok(client) => {
                            info!("Reverse connection {} established", client_id);

                            let client_arc = Arc::new(RwLock::new(client));

                            // Register client to receive dirty region notifications
                            let regions_arc = client_arc.read().await.get_receiver_handle();
                            let receiver = DirtyRegionReceiver::new(Arc::downgrade(&regions_arc));
                            framebuffer.register_receiver(receiver).await;

                            clients.write().await.push(client_arc.clone());

                            let _ = server_event_tx.send(ServerEvent::ClientConnected { client_id });

                            // Spawn task to handle client messages
                            let client_arc_clone = client_arc.clone();
                            tokio::spawn(async move {
                                let result = {
                                    let mut client = client_arc_clone.write().await;
                                    client.handle_messages().await
                                };
                                if let Err(e) = result {
                                    error!("Reverse client {} message handling error: {}", client_id, e);
                                }
                            });

                            // Handle client events
                            while let Some(event) = client_event_rx.recv().await {
                                match event {
                                    ClientEvent::KeyPress { down, key } => {
                                        let _ = server_event_tx.send(ServerEvent::KeyPress {
                                            client_id,
                                            down,
                                            key,
                                        });
                                    }
                                    ClientEvent::PointerMove { x, y, button_mask } => {
                                        let _ = server_event_tx.send(ServerEvent::PointerMove {
                                            client_id,
                                            x,
                                            y,
                                            button_mask,
                                        });
                                    }
                                    ClientEvent::CutText { text } => {
                                        let _ = server_event_tx.send(ServerEvent::CutText { client_id, text });
                                    }
                                    ClientEvent::Disconnected => {
                                        break;
                                    }
                                }
                            }

                            // Remove client from list
                            let mut clients_guard = clients.write().await;
                            clients_guard.retain(|c| !Arc::ptr_eq(c, &client_arc));

                            let _ = server_event_tx.send(ServerEvent::ClientDisconnected { client_id });

                            info!("Reverse client {} disconnected", client_id);
                        }
                        Err(e) => {
                            error!("Failed to initialize VNC client for reverse connection: {}", e);
                        }
                    }
                }
                Err(e) => {
                    error!("Failed to connect to {}:{}: {}", host, port, e);
                    let _ = result_tx.send(Err(e));
                }
            }
        });

        // Wait for connection to complete before returning to caller
        match result_rx.await {
            Ok(Ok(())) => Ok(client_id),
            Ok(Err(e)) => Err(e),
            Err(_) => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Reverse connection task died unexpectedly"
            )),
        }
    }

    /// Connects the VNC server to a VNC repeater, establishing a reverse connection.
    ///
    /// This allows a client behind a NAT or firewall to connect to the server.
    /// The function waits for the actual connection to be established before returning.
    ///
    /// # Arguments
    ///
    /// * `repeater_host` - The hostname or IP address of the VNC repeater.
    /// * `repeater_port` - The port of the VNC repeater.
    /// * `repeater_id` - The ID to use when connecting to the repeater.
    ///
    /// # Returns
    ///
    /// `Ok(client_id)` if the connection to the repeater is successfully established, where `client_id`
    /// is the unique identifier assigned to the new repeater client.
    /// Returns `Err(std::io::Error)` if a client ID counter overflow occurs, or if there is an issue
    /// connecting to the repeater or handling the client.
    pub async fn connect_repeater(
        &self,
        repeater_host: String,
        repeater_port: u16,
        repeater_id: String,
    ) -> Result<usize, std::io::Error> {
        // Safely increment client ID counter and check for overflow
        let client_id_raw = NEXT_CLIENT_ID.fetch_add(1, Ordering::SeqCst);
        if client_id_raw == 0 || client_id_raw >= u64::MAX - 1000 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Client ID counter overflow"
            ));
        }
        let client_id = client_id_raw as usize;

        let framebuffer = self.framebuffer.clone();
        let desktop_name = self.desktop_name.clone();
        let password = self.password.clone();
        let clients = self.clients.clone();
        let server_event_tx = self.event_tx.clone();

        // Use oneshot channel to wait for connection result before returning
        let (result_tx, result_rx) = tokio::sync::oneshot::channel();

        tokio::spawn(async move {
            let (client_event_tx, mut client_event_rx) = mpsc::unbounded_channel();

            let connection_result = repeater::connect_repeater(
                repeater_host,
                repeater_port,
                repeater_id,
                framebuffer.clone(),
                desktop_name,
                password,
                client_event_tx,
            )
            .await;

            // Send connection result back to caller
            let _ = result_tx.send(connection_result.as_ref().map(|_| ()).map_err(|e| {
                std::io::Error::new(e.kind(), e.to_string())
            }));

            match connection_result {
                Ok(client) => {
                    info!("Repeater connection {} established", client_id);

                    let client_arc = Arc::new(RwLock::new(client));

                    // Register client to receive dirty region notifications (libvncserver style)
                    let regions_arc = client_arc.read().await.get_receiver_handle();
                    let receiver = DirtyRegionReceiver::new(Arc::downgrade(&regions_arc));
                    framebuffer.register_receiver(receiver).await;

                    clients.write().await.push(client_arc.clone());

                    let _ = server_event_tx.send(ServerEvent::ClientConnected { client_id });

                    // Spawn task to handle client messages
                    // Note: Same write lock behavior as regular clients (see handle_client)
                    let client_arc_clone = client_arc.clone();
                    tokio::spawn(async move {
                        let result = {
                            let mut client = client_arc_clone.write().await;
                            client.handle_messages().await
                        };
                        if let Err(e) = result {
                            error!("Repeater client {} message handling error: {}", client_id, e);
                        }
                    });

                    // Handle client events
                    while let Some(event) = client_event_rx.recv().await {
                        match event {
                            ClientEvent::KeyPress { down, key } => {
                                let _ = server_event_tx.send(ServerEvent::KeyPress {
                                    client_id,
                                    down,
                                    key,
                                });
                            }
                            ClientEvent::PointerMove { x, y, button_mask } => {
                                let _ = server_event_tx.send(ServerEvent::PointerMove {
                                    client_id,
                                    x,
                                    y,
                                    button_mask,
                                });
                            }
                            ClientEvent::CutText { text } => {
                                let _ = server_event_tx.send(ServerEvent::CutText { client_id, text });
                            }
                            ClientEvent::Disconnected => {
                                break;
                            }
                        }
                    }

                    // Remove client from list
                    let mut clients_guard = clients.write().await;
                    clients_guard.retain(|c| !Arc::ptr_eq(c, &client_arc));

                    let _ = server_event_tx.send(ServerEvent::ClientDisconnected { client_id });

                    info!("Repeater client {} disconnected", client_id);
                }
                Err(e) => {
                    error!("Failed to connect to repeater: {}", e);
                }
            }
        });

        // Wait for connection to complete before returning to caller
        match result_rx.await {
            Ok(Ok(())) => Ok(client_id),
            Ok(Err(e)) => Err(e),
            Err(_) => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                "Repeater connection task died unexpectedly"
            )),
        }
    }
}
